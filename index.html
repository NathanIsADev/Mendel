<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mendelsche regel II</title>
<style>
  :root{
    --bg:#f6fffb; --card:#ffffff; --accent:#0b84ff; --ok:#16a34a; --bad:#ef4444; --muted:#44505a;
  }
  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Arial, sans-serif;background:linear-gradient(180deg,var(--bg),#ffffff);color:#0b2b3a}
  .wrap{max-width:1000px;margin:18px auto;padding:18px;border-radius:14px;background:var(--card);box-shadow:0 12px 40px rgba(2,10,20,0.06)}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:0;font-size:20px}
  .sub{color:var(--muted);font-size:13px}
  .main{display:grid;grid-template-columns:1fr 360px;gap:14px;margin-top:14px}
  .card{background:#fbfeff;border-radius:10px;padding:12px;border:1px solid #e6f8ff}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .bigbtn{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:white;font-weight:800;cursor:pointer}
  .ghost{background:#eef7ff;color:#074a9b}
  .gametes{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .tile{min-width:88px;padding:10px;border-radius:10px;border:1px solid #e6f8ff;background:white;text-align:center;cursor:pointer;user-select:none;transition:transform .12s, box-shadow .12s}
  .tile:hover{transform:translateY(-4px);box-shadow:0 8px 20px rgba(11,132,255,0.08)}
  .tile.selected{box-shadow:0 12px 28px rgba(11,132,255,0.14);transform:scale(1.03);background:linear-gradient(180deg,#fffefc,#fbfdff)}
  .targetBox{padding:12px;border-radius:10px;border:2px dashed #e6f8ff;text-align:center;background:#fffdfa}
  .childBox{margin-top:10px;padding:12px;border-radius:10px;border:2px dashed #f1f3f4;background:#fff}
  .status{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .stat{background:#fff;padding:8px;border-radius:8px;border:1px solid #eef6ff;font-weight:800}
  .progressWrap{height:12px;background:#eef7ff;border-radius:8px;overflow:hidden;margin-top:10px}
  .progress{height:100%;background:linear-gradient(90deg,#ffe082,#ffb703);width:0%;transition:width .4s}
  .message{font-weight:800;margin-top:10px}
  .ok{color:var(--ok)} .bad{color:var(--bad)}
  .footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
  .small{font-size:13px;color:var(--muted)}
  @media (max-width:880px){ .main{grid-template-columns:1fr} .card{margin-bottom:12px} }
  /* celebration */
  .confetti { position:fixed; left:50%; top:20%; transform:translateX(-50%); pointer-events:none; z-index:9999; }
  @keyframes pop { 0%{transform:translateY(0) scale(.6);opacity:0} 50%{transform:translateY(-6px) scale(1.05);opacity:1} 100%{transform:translateY(0) scale(1);opacity:1} }
</style>
</head>
<body>
  <div class="wrap" role="application">
    <header>
      <div>
        <h1>Mendelsche regel II</h1>
        <div class="sub">W√§hle je eine Karte von Mutter und Vater. Triff die gesuchte Kombination(Farbe & Form).</div>
      </div>
      <div class="status">
        <div class="stat">Level <span id="level">1</span></div>
        <div class="stat">Punkte <span id="score">0</span></div>
        <div class="stat">Leben <span id="lives">3</span></div>
        <div class="stat">Zeit <span id="timer">30</span>s</div>
      </div>
    </header>

    <div class="main">
      <section class="card" aria-labelledby="game">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong id="game">Spiel</strong><div class="small">Ziel: Erziele <span id="needCount">5</span> richtige Treffer, um aufzusteigen.</div></div>
          <div class="controls">
            <button class="bigbtn" id="start">Neues Spiel</button>
            <button class="bigbtn ghost" id="helpBtn">Kurze Erkl√§rung</button>
          </div>
        </div>

        <div style="margin-top:12px" class="targetBox">
          <div class="small">Ziel-Ph√§notyp:</div>
          <div id="targetText" style="font-size:18px;font-weight:900;margin-top:6px">‚Äî</div>
          <div class="progressWrap" aria-hidden="true"><div id="progress" class="progress"></div></div>
        </div>

        <div style="margin-top:12px">
          <div class="small">Mutter ‚Äî Karten (klicke 1)</div>
          <div id="pack1" class="gametes" aria-live="polite"></div>

          <div class="small" style="margin-top:10px">Vater ‚Äî Karten (klicke 1)</div>
          <div id="pack2" class="gametes" aria-live="polite"></div>
        </div>

        <div class="childBox" id="childBox">W√§hle zuerst eine Karte von Mutter, dann eine von Vater. Dr√ºcke Best√§tigen.</div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="bigbtn" id="confirm">Best√§tigen</button>
          <button class="bigbtn ghost" id="skip">√úberspringen (‚àí1 Leben)</button>
          <button class="bigbtn ghost" id="preset">Preset (einfach)</button>
        </div>

        <div id="info" class="message small" style="margin-top:8px"></div>
      </section>

      <aside class="card">
        <div><strong>Tipps & Ziel</strong></div>
        <ul class="small">
          <li>W√§hle schnell: je schneller, desto mehr Punkte.</li>
          <li>Falsche Wahl verliert 1 Leben ‚Äî 0 Leben = Game Over.</li>
          <li>Ziel jedes Levels: <strong id="goalText">5 richtige Treffer</strong>.</li>
        </ul>

        <hr style="margin:10px 0">

        <div><strong>Highscore</strong></div>
        <div id="message" class="small">Viel Erfolg ‚Äî starte ein neues Spiel!</div>
        <div style="margin-top:10px">
          <button class="bigbtn ghost" id="restart">Neustart</button>
        </div>
      </aside>
    </div>

    <div class="footer">Kurz: "Gene verhalten sich unabh√§ngig" ‚Üí hier: Mutter & Vater geben je eine Karte, daraus entsteht die Kombination. (Mehr nicht n√∂tig.)</div>
  </div>

  <!-- confetti container -->
  <div id="confettiContainer" class="confetti" aria-hidden="true"></div>

<script>
(function(){
  // --- Simple, fun game with plain words
  // Traits simplified: Farbe (Gelb/Gr√ºn) & Form (Rund/Runzelig)
  const colors = ['Gelb','Gr√ºn']; // color = A gene dominance
  const shapes = ['Rund','Runzelig']; // shape = B gene dominance

  // DOM
  const pack1 = document.getElementById('pack1'), pack2 = document.getElementById('pack2');
  const targetText = document.getElementById('targetText'), childBox = document.getElementById('childBox');
  const scoreEl = document.getElementById('score'), livesEl = document.getElementById('lives'), levelEl = document.getElementById('level'), timerEl = document.getElementById('timer');
  const confirmBtn = document.getElementById('confirm'), skipBtn = document.getElementById('skip'), startBtn = document.getElementById('start'), presetBtn = document.getElementById('preset');
  const info = document.getElementById('info'), message = document.getElementById('message'), helpBtn = document.getElementById('helpBtn');
  const progress = document.getElementById('progress'), needCountSpan = document.getElementById('needCount'), goalText = document.getElementById('goalText');

  // game state
  let selected1=null, selected2=null, score=0, lives=3, level=1, timeLeft=30, timerId=null;
  let needCorrect = 5, correctCount=0, currentTarget='', running=false;

  // sound using WebAudio (no files)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function playTone(freq, type='sine', dur=0.12, vol=0.08){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
    setTimeout(()=>{ try{o.stop()}catch(e){} }, dur*1000);
  }

  // helper: create card data (simple, not showing genotypes)
  function makeCards(genotype){
    // genotype is like 'AaBb' internally, but we hide letters from UI
    // we generate unique gametes with simple letters representing one allele from each gene
    const A = genotype.slice(0,2), B = genotype.slice(2,4);
    const a = [A[0],A[1]], b = [B[0],B[1]];
    const gam = [];
    a.forEach(x=>b.forEach(y=> gam.push(x+y)));
    return Array.from(new Set(gam)); // e.g. ['AB','Ab','aB','ab'] but we will show as cards
  }

  function prettyCardLabel(gam){
    // gam like 'Ab' -> show symbolic but friendly: first letter determines color, second determines shape
    // We map uppercase A/B to dominant -> Gelb/Rund
    const color = (gam[0] === gam[0].toUpperCase()) ? 'Gelb' : 'Gr√ºn';
    const shape = (gam[1] === gam[1].toUpperCase()) ? 'Rund' : 'Runzelig';
    return { label: color + ' | ' + shape, color, shape };
  }

  function randomParentGen(preset='normal'){
    // produce hidden genotype strings used internally: 'AaBb' style
    if(preset==='easy'){ return ['AABB','aabb'][Math.floor(Math.random()*2)]; } // easy
    if(preset==='normal'){ // AaBb x AaBb equivalent: return random combination with mix
      const p = ['AA','Aa','aa'][Math.floor(Math.random()*3)];
      const q = ['BB','Bb','bb'][Math.floor(Math.random()*3)];
      return p+q;
    }
    // fallback
    return ['AaBb','AAbb','aaBB'][Math.floor(Math.random()*3)];
  }

  function buildParents(presetOpt){
    // returns two gen strings
    const p1 = randomParentGen(presetOpt || 'normal');
    const p2 = randomParentGen(presetOpt || 'normal');
    return [p1,p2];
  }

  // create UI tiles from parent genotypes
  function renderPacks(gen1, gen2){
    pack1.innerHTML=''; pack2.innerHTML=''; selected1=selected2=null; childBox.textContent = 'W√§hle zuerst eine Karte von Mutter, dann eine von Vater.';
    const cards1 = makeCards(gen1);
    const cards2 = makeCards(gen2);
    cards1.forEach(g=>{
      const {label} = prettyCardLabel(g);
      const el = document.createElement('div'); el.className='tile'; el.textContent = label;
      el.addEventListener('click', ()=>{ select(1,g,el); });
      pack1.appendChild(el);
    });
    cards2.forEach(g=>{
      const {label} = prettyCardLabel(g);
      const el = document.createElement('div'); el.className='tile'; el.textContent = label;
      el.addEventListener('click', ()=>{ select(2,g,el); });
      pack2.appendChild(el);
    });
    // calculate distribution and pick a target
    const dist = punnettDistribution(gen1, gen2);
    currentTarget = pickWeighted(dist);
    targetText.textContent = currentTarget;
    updateProgress();
  }

  function select(parent, gam, el){
    if(parent===1){
      selected1 = gam;
      pack1.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected'));
      el.classList.add('selected');
    } else {
      selected2 = gam;
      pack2.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected'));
      el.classList.add('selected');
    }
    if(selected1 && selected2){
      const childGen = combineGametesToGenotype(selected1, selected2);
      const ph = phenotypeOfGenotype(childGen);
      childBox.innerHTML = '<div style="font-weight:900;font-family:monospace">'+childGen+'</div><div style="margin-top:6px">Baby: <strong>'+ph+'</strong></div>';
    }
  }

  // internal helpers (similar to earlier logic)
  function combineGametesToGenotype(g1,g2){
    // g1,g2 are two-letter strings like 'Ab' and 'aB'
    const a = [g1[0], g2[0]], b = [g1[1], g2[1]];
    function order(arr){ return arr.sort((x,y)=>{ if(x===y) return 0; if(x===x.toUpperCase() && y!==y.toUpperCase()) return -1; if(y===y.toUpperCase() && x!==x.toUpperCase()) return 1; return x.localeCompare(y); }).join(''); }
    return order(a)+order(b); // e.g. 'AaBb'
  }
  function phenotypeOfGenotype(gen){
    const A = gen.slice(0,2), B = gen.slice(2,4);
    const hasA = (A[0]==='A'||A[1]==='A'), hasB = (B[0]==='B'||B[1]==='B');
    return (hasA?'Gelb':'Gr√ºn') + ' & ' + (hasB?'Rund':'Runzelig');
  }
  function punnettDistribution(g1,g2){
    const g1gam = makeCards(g1), g2gam = makeCards(g2);
    const probs1 = normalize(g1gam), probs2 = normalize(g2gam);
    const rows = Object.keys(probs1), cols = Object.keys(probs2);
    const counts = {};
    rows.forEach(r=>cols.forEach(c=>{
      const child = combineGametesToGenotype(r,c);
      const ph = phenotypeOfGenotype(child);
      const p = probs1[r]*probs2[c];
      counts[ph] = (counts[ph]||0)+p;
    }));
    return counts;
  }
  function normalize(arr){ const c={}; arr.forEach(x=>c[x]=(c[x]||0)+1); const t=arr.length; Object.keys(c).forEach(k=>c[k]=c[k]/t); return c; }
  function pickWeighted(counts){ let total=0; const items=[]; for(const k in counts){ total += counts[k]; items.push({k, w:counts[k]}); } let r=Math.random()*total; for(const it of items){ r -= it.w; if(r<=0) return it.k; } return items[0].k; }

  // progress / goal logic
  function startNewGame(presetOpt){
    // reset
    score=0; lives=3; level=1; timeLeft=30; correctCount=0; needCorrect=5; running=true;
    scoreEl.textContent=score; livesEl.textContent=lives; levelEl.textContent=level; timerEl.textContent=timeLeft;
    needCountSpan.textContent = needCorrect; goalText.textContent = needCorrect + ' richtige Treffer';
    info.textContent='Spiel l√§uft ‚Äî gute Reaktionen bringen Punkte!';
    message.textContent='Viel Erfolg!';
    // build parents & render
    const [g1,g2] = buildParentsForLevel(presetOpt);
    renderPacks(g1,g2);
    startTimer();
  }

  function buildParentsForLevel(presetOpt){
    // for clarity: presetOpt can be 'easy' or 'normal' or undefined
    const p1 = presetOpt==='easy' ? 'AABB' : (presetOpt==='easy2'? 'AAbb' : randomGen());
    const p2 = presetOpt==='easy' ? 'aabb' : randomGen();
    return [p1,p2];
  }
  function randomGen(){ return ['AA','Aa','aa'][rand(3)] + ['BB','Bb','bb'][rand(3)]; }
  function rand(n){ return Math.floor(Math.random()*n); }

  function updateProgress(){
    const percent = (correctCount / needCorrect) * 100;
    progress.style.width = Math.min(100, percent) + '%';
    needCountSpan.textContent = needCorrect - correctCount;
  }

  function submitChoice(){
    if(!selected1 || !selected2){ info.textContent='W√§hle je eine Karte von Mutter und Vater.'; info.style.color=''; playTone(220, 'sine', 0.06); return; }
    const childGen = combineGametesToGenotype(selected1, selected2);
    const ph = phenotypeOfGenotype(childGen);
    if(ph === currentTarget){
      // correct
      const points = 10 + Math.max(0, Math.floor(timeLeft/3));
      score += points; scoreEl.textContent = score;
      correctCount += 1; updateProgress();
      info.textContent = 'Richtig! +' + points + ' Punkte';
      info.style.color = 'green';
      playTone(880, 'sine', 0.10);
      // small confetti
      showConfetti();
      if(correctCount >= needCorrect){
        levelUp();
        return;
      }
    } else {
      // wrong
      lives -= 1; livesEl.textContent = lives;
      info.textContent = 'Falsch! Richtiger: ' + currentTarget;
      info.style.color = 'crimson';
      playTone(160, 'sawtooth', 0.18);
      if(lives <= 0){ gameOver(); return; }
    }
    // reset selection and refresh target with same parents but new distribution
    selected1 = selected2 = null; pack1.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected')); pack2.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected'));
    childBox.textContent = 'W√§hle zuerst eine Karte von Mutter, dann eine von Vater.';
    // recompute current target from same parents (slightly random)
    // to make rounds varied, rebuild parents sometimes
    if(Math.random() < 0.35){ const [g1,g2] = buildParentsForLevel(); renderPacks(g1,g2); } else {
      // same parents, new pick
      const gen1 = pack1.dataset.gen || randomGen(); const gen2 = pack2.dataset.gen || randomGen();
      const dist = punnettDistribution(gen1, gen2); currentTarget = pickWeighted(dist); targetText.textContent = currentTarget;
    }
  }

  function levelUp(){
    level += 1; levelEl.textContent = level;
    score += 50; scoreEl.textContent = score;
    info.textContent = 'Level geschafft! Weiter zu Level ' + level;
    playTone(1200,'sine',0.18);
    // increase difficulty
    needCorrect = Math.max(3, 5 + (level-1)*1); // need more correct each level
    correctCount = 0;
    // shorten time a bit
    timeLeft = Math.max(8, 30 - (level-1)*3);
    timerEl.textContent = timeLeft;
    needCountSpan.textContent = needCorrect;
    goalText.textContent = needCorrect + ' richtige Treffer';
    // new parents for new level
    const [g1,g2] = buildParentsForLevel();
    renderPacks(g1,g2);
    updateProgress();
  }

  function skipTurn(){
    if(!confirm('√úberspringen kostet 1 Leben. Sicher?')) return;
    lives = Math.max(0, lives-1); livesEl.textContent = lives;
    info.textContent = '√úbersprungen (‚àí1 Leben).';
    playTone(220,'sine',0.08);
    if(lives<=0) gameOver();
    // next round
    selected1=selected2=null; pack1.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected')); pack2.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected'));
    const [g1,g2] = buildParentsForLevel();
    renderPacks(g1,g2);
  }

  function gameOver(){
    running=false;
    clearInterval(timerId);
    message.textContent = 'Game over ‚Äî Du hast ' + score + ' Punkte erreicht.';
    info.textContent = 'Klicke "Neues Spiel" oder "Neustart" um erneut zu starten.';
    info.style.color = 'crimson';
    playTone(120,'sine',0.35);
  }

  // timer
  function startTimer(){
    clearInterval(timerId);
    timerId = setInterval(()=>{
      timeLeft -= 1;
      timerEl.textContent = timeLeft;
      if(timeLeft <= 0){
        lives = Math.max(0, lives-1); livesEl.textContent = lives;
        info.textContent = 'Zeit abgelaufen! (‚àí1 Leben). Richtiger war: ' + currentTarget;
        playTone(140, 'triangle', 0.12);
        if(lives<=0){ gameOver(); return; }
        // next round
        selected1 = selected2 = null;
        pack1.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected'));
        pack2.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected'));
        const [g1,g2] = buildParentsForLevel();
        renderPacks(g1,g2);
      }
    }, 1000);
  }

  // helper show confetti (simple emoji burst)
  const confettiContainer = document.getElementById('confettiContainer');
  function showConfetti(){
    const emoji = ['üéâ','‚ú®','üåü','üëè','üí•'];
    for(let i=0;i<10;i++){
      const el = document.createElement('div'); el.style.position='absolute';
      el.style.fontSize = (12+Math.random()*18) + 'px';
      el.style.left = (Math.random()*80 - 40) + 'px';
      el.style.top = (Math.random()*60 - 30) + 'px';
      el.style.opacity = '0';
      el.style.transform = 'translateY(0)';
      el.textContent = emoji[Math.floor(Math.random()*emoji.length)];
      el.style.animation = 'pop .6s ease forwards';
      confettiContainer.appendChild(el);
      setTimeout(()=>{ el.remove(); },800);
    }
  }

  // UI buttons
  startBtn.addEventListener('click', ()=>{ startNewGame('normal'); });
  presetBtn.addEventListener('click', ()=>{ startNewGame('easy'); });
  confirmBtn.addEventListener('click', ()=>{ if(!running) { info.textContent='Starte zuerst ein neues Spiel.'; return; } submitChoice(); });
  skipBtn.addEventListener('click', ()=>{ if(!running){ info.textContent='Starte zuerst ein neues Spiel.'; return; } skipTurn(); });
  document.getElementById('restart').addEventListener('click', ()=>{ location.reload(); });
  helpBtn.addEventListener('click', ()=>{ alert('Kurz: Mutter und Vater geben je eine Karte (eine Eigenschaft von Farbe & Form). Aus beiden Karten entsteht eine Kombination. Ziel: Triff die gesuchte Kombination.'); });

  // init small demo
  function initDemo(){
    // render demo parents (not started game)
    const g1 = 'AaBb', g2='AaBb';
    renderPacks(g1,g2);
    scoreEl.textContent=score; livesEl.textContent=lives; levelEl.textContent=level; timerEl.textContent=timeLeft;
    needCountSpan.textContent = needCorrect;
  }
  initDemo();

  // helpers to build parents used by renderPacks - store data on packs
  function buildParentsForLevel(presetOpt){
    // more varied combination depending on level and preset
    if(presetOpt==='easy'){
      const g1 = 'AABB', g2='aabb';
      pack1.dataset.gen = g1; pack2.dataset.gen = g2;
      return [g1,g2];
    }
    // otherwise random with higher chance of heterozygous in early levels
    function sampleGene(){
      // more Aa early, more AA/aa later as level increases
      const probs = level < 3 ? ['Aa','Aa','AA','aa'] : ['Aa','AA','aa','Aa'];
      return probs[rand(probs.length)];
    }
    const g1 = sampleGene() + sampleGene().replace(/A|a/g, ch => ch==='A'?'B':'b'); // quick diff
    const g2 = sampleGene() + sampleGene().replace(/A|a/g, ch => ch==='A'?'B':'b');
    pack1.dataset.gen = g1; pack2.dataset.gen = g2;
    return [g1,g2];
  }

  // expose small helper for rand
  function rand(n){ return Math.floor(Math.random()*n); }

  // start button triggers game start - implemented above (startNewGame)
})();
</script>
</body>
</html>




